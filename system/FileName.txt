实验二  请求式分页存储管理算法设计与实现
模拟请求页式存储管理中硬件的地址转换和缺页中断，并用先进先出调度算法（FIFO）处理缺页中断

1．内容：模拟请求页式存储管理中硬件的地址转换和缺页中断处理
2．思想：
装入新页置换旧页时，若旧页在执行中没有被修改过，则不必将该页重写磁盘。因此，页表中增加是否修改过的标志，执行“存”指令和“写”指令时将对应
的修改标志置成“1”表示修改过，否则为“0”表示未修改过。页表格式如下：
页号	标志	页架号	修改标志	在磁盘上位置

     				
3．要求及方法：
① 设计一个地址转换程序来模拟硬件的地址转换和缺页中断。当访问的页在主存时则形成绝对地址，但不去模拟指令的执行，可以输出转换后的绝对地址来表示
一条指令已执行完成。当访问的页不在主存中时，则输出“*页号”来表示硬件产生了一次缺页中断。模拟地址转换流程见图1。
② 编制一个FIFO页面调度程序；FIFO页面调度算法总是先调出作业中最先进入主存中的哪一页。因此可以用一个数组来表示（或构成）页号队列。数组中每
个元素是该作业已在主存中的页面号，假定分配给作业的页架数为m，且该作业开始的m页已装入主存，则数组可由m个元素构成。
P[0]，P[1]，P[2]，…，P[m-1]
它们的初值为P[0]：=0，P[1]：=1，P[2]：=2，…，P[m-1]：=m-1
用一指针K指示当要调入新页时应调出的页在数组中的位置，K的初值为“0”，当产生缺页中断后，操作系统总是选择P[K]所指出的页面调出，然后执行：
P[K]：=要装入的新页页号
K：=(k+1)mod m
在实验中不必实际地启动磁盘执行调出一页和装入一页的工作，若即将调出的页修改过，则用输出“OUT调出的页号”和“IN要装入的新页页号”来模拟一
次调出和装入过程；否则，输出“IN要装入的新页页号”来模拟一次调出和装入过程，模拟程序的流程图见后。
按流程控制过程如下：
提示：输入指令的页号和页内偏移和是否存指令，若d为-1则结束，否则进入流程控制过程，得P1和d，查表在主存时，绝对地址=P1×1024+d
③ 假定主存中页架大小为1024个字节，现有一个共7页的作业，其副本已在磁盘上。系统为该作业分配了4个页架，且该作业的第0页至第3页已装入内存，
其余3页未装入主存，该作业的页表如下：
页号	标志	页架号	修改标志	在磁盘上位置
0	1	5	0	011
1	1	8	0	012
2	1	9	0	013
3	1	1	0	021
4	0		0	022
5	0		0	023
6	0		0	121
如果该作业依次执行的指令序列如下表所示：
操作	页号	页内地址	操作	页号	页内地址
+	0	070	移位	4	053
+	1	050	+	5	023
×	2	015	存	1	037
存	3	021	取	2	078
取	0	056	+	4	001
－	6	040	存	6	084
依次执行上述指令调试你所设计的程序（仅模拟指令的执行，不考虑序列中具体操作的执行）。
④ 为进一步考察程序的执行，可自行确定若干组指令，运行程序，核对执行结果。
4．书写实验报告：
① 实验题目；
② 程序中所用的数据结构及说明；
③ 源程序并附上必要的说明；
④ 按照指令的执行序列，打印输出结果：绝对地址或调出、调入的页号。



图1    模拟算法流程

else {
			cout << "*" << order[0].o_page << endl;					//输出所缺的页
			num++;													//缺页次数加一
			out_page = p[k];										//将当前替换指针所指的页取出
			if (page[out_page].change_flag == 1) {					//判断换出的页是否被修改过
				cout << "OUT： " << out_page;
				cout << "//该页已被修改过，需调出后重写磁盘，该页在磁盘中的位置为：" << page[out_page].palce << endl;
			}
			cout << "IN：  " << real_page << endl;
			p[k] = real_page;										//将新入内存的页的页号放入数组中
			k = (k + 1) % 4;										//移动替换指针
			page[real_page].flag = 1;								//将新入内存的页标志置为1
			page[out_page].flag = 0;								//将调出页的页标志置为0
			page[real_page].change_flag = 0;						//将新入内存的页修改标志置为0
			if (order[0].operate == "存")
				page[real_page].change_flag = 1;
			page[real_page].frame = page[out_page].frame;			//将调出页的页架号付给新入的页
		}
		cout << "----------------------------" << endl;
		order.erase(order.begin());									//删除容器中第一个元素
	}
	cout << "当前数据下的FIFO算法缺页率为： " << num / order.capacity();//缺页次数除以操作总数
	return 0;
}
――――――――――――――――
版权声明：本文为CSDN博主「爱学习爱生活111」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_40819191/article/details/121637445